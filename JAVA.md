기술면접(JAVA)
자바의 특징
===
```
*운영체제에 독립적
	*JVM이 운영체제와 실행파일 중간에 존재하여 JVM위에서 동작
	*java 코드는 컴파일 후 자바바이트코드로 만들어지며 자바 바이트 코드를 동작하기위해 자바가상머신이 필요하다. 실행하려는 운영체제에서 자바가상머신을 사용하여 자바 바이트코드를 동작시킨다.
	단 자바 바이트코드와 달리 jvm은 운영체제에 종속적이기에 각 운영체제에 맞는 jvm이 필요 또한 jvm이라는 중간과정이 추가되어 속도가 느림
*객체지향 언어
*메모리관리
	*가비지컬렉터가 메모리관리
```



접근제어자
===
```
많은 접근권한																						좁은접근권한
public > protected > default > private 

public : 모든접근 권한
protected : 같은 패키지 + 상속
default : 같은 패키지 
private : 같은 클래스
```

static
===
```
static method : 객채 생성없이 사용될 수 있는 메소드(맴버변수 사용 불가)
static var : 클래스간 공유되는 변수
```

변수
===
```
로컬변수 : 메소드 내부에 정의된 변수로 스코프는 매소드 내부
멤버변수 : 메소드 밖 클래스 내부에 선언된 변수
정적변수 : 객채생성 없이 사용, 객체간 공유
```

제너릭
===
```
모든 타입을 사용 할 수 있도록 하는 기법
물론 Object를 사용 할 수 있으나 형변환이 필요
```

클래스 vs 객체 vs 인스턴스
===
```
클래스 : 대상을 추상화하여 만들어진 코드
객채 : 클래스로 만들어진 인스턴스 대표
인스턴스 : 객채 중 특정 1개 클래스로 구현된 실체
```

오버로딩 vs 오버라이딩
===
```
오버로딩 : 같은 이름의 여러 메소드가 다른 매개변수를 같는 것
오버라이딩 : 상위 클래스의 메소드를 재정의 하는 것
```

Collection별 특징
===
```
List : 중복 O, 순서보장 O
Set : 중복 X , 순서보장 X
Map : key,Value로 구성되어 있어 Key로 value를 찾는다 중복 X 
```

상속 vs 컴포지션
==
```
상속은 is a 
컴포지션은 has a 
Ex) 
	아반떼 is a 자동차 -> 상속 
	자동차 has a 바퀴 -> 컴포지션
```

## 인터페이스 vs 추상클레스

```
인터페이스 추상클래스 모두 하위클래스에게 메소드의 구현을 강제 할 수 있다.
인터페이스는 공통 클래스의 로직을 포함 할 수 없으며 추상클래스는 하위 클래스들이 사용할 공통로직을 포함한 메소드를 작성 할 수 있다.

인터페이스는 다중상속이 가능하지만 추상클래스는 단일상속
```

## Call by value VS call by Reference

```
call by value : 메모리에 있는 값을 전달
call by Reference : 주소 값을 전달
```

## equals( )와 ==의 차이 

```
==(연산자)
primitive, wrapper 타입의 경우 두 변수의 값을 비교하게 된다.
객체의의 변수의 경우 두 값의 주소값을 비교하게된다.

equals(메소드)
object 객체에 있는 메소드로 인스턴스1.equals(인스턴스2)
하게되면 두 인스턴스에 들어있는 내용을 비교하게된다.
```



## String, StringBuffer, StringBuilder

```
String vs StringBuffer,StringBuilder
String은 불변객체이다. 즉
String str = WOW;
str = str + LOL ;
를 작성하게 될경우 str의 주소가 가르키는 메모리의 값이 바뀌는 것이 아닌 변수 str이 새로 만들어진 매모리 주소를 참조하게 된다.
그러나 stringBuffer builder의경우 
sb.append("WOW");
sb.append("LOL");
을 한다면 새로운 영역을 생성하는 것이 아닌 기존의 영역의 값을 바꾼다.

StringBuffer Vs StringBuilder
둘의 차이는 동기화의 여부다. 
멀티 스레드 환경의 경우 StringBuffer를 사용
단일스레드 환경의 경우 StrungBuilder (더 빠르다)
```



 자바 메모리관리

```
런타임 시 자바 메모리는 크게 힙, 스텍, 스테틱으로 구분

스테틱: jvm 구동중 각 클레스의 정보를 가지고 있는 메모리 객체간 공유할 수 있는 static 변수, static 메소드를 가지고 있으며 객체의 생성 없이 사용할 수 있음
프로그램이 종로 전 까지 모든 영역에서 사용이 가능하지만 무분별하게 사용되면 메모리 부족 상황이 발생 할 수 있음

Heap
new로 생성된 객체들이 저장되는 영역으로 프로그램 실행중 생성되는 모든 객체는 Heap에서 동적ㅇ으로 할당, 가비지 컬렉터에 의해 주기적으로 메모리를 반환 instance에는 맴버변수 등을 가지고있다..

stack
메소드 호출을 관리하는 메모리 영역으로 각 메소드들의 로컬변수를 저장하게된다. 메소드는 last in first out 방식으로 진행되어 stack구조를 가진다.
```

\- 비동기와 동기의 차이

```
동기화
동기화는 하나의 작업이 끝나기 전에 다른 작업을 시행 할 수없는 상태를 의미하며 
Blocking IO 발생

비동기화
작업의 결과를 바로 받지 않고 추후 다른 방식 직/간접적인 방식으로 결과를 받는 것이며 작업의 완료를 기다리지 않고 다음 작업을 진행한다.
```



SOLID

```
Single Responsibility Principle
	하나의 클래스는 하나의 역할을 해야한다.
Open-Close principle
	확장에는 개방적 (기존의 코드)수정에는 닫혀있어야한다.
Likov Subsittution principle
	하위 타입의 인스턴스는 상위 타입의 인스턴스 역할을 할 수 있어야한다.
Interface segregation principle
	인터페이스는 필요한 기능의 최소한으로 상속받아야한다
Dependency inversion principle
	변하기 쉬운 것에 의존하지 말라 car 가 interface 타이어, 스노우 타이어 가 있다면 타이어가 보다 상위 인터페이스이기에 타이어를 상속받아야한다.
```

객체지향 언어의 특징

```
캡슐화
	함수와 속성을 하나의 클래스로 묶어서 사용하는 것
상속
	상위 클래스의 속성과 메소드를 받아 재사용 사용하는것
추상화
	실제세계의 대상을 모델화 하는 방법으로 주요한 속성을 가지고 모델화한느 기법
다형성
	같은 이름의 메소드라도 하위 클래스에서 재정의 한다면 다른 내부동작을 하게 됨
정보은닉
	내부의 클래스 내부의 구조를 알 필요 없이 메소드를 통해 접근하여 속성의 정보를 은닉
```

https://blog.naver.com/z1004man

